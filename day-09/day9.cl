#!/usr/bin/sbcl --script
(require :uiop)
(defun follow (head tail dir)
  (let* ((headx (car head))
	 (heady (cadr head))
	 (tailx (car tail))
	 (taily (cadr tail))
	 (diffx (- headx tailx))
	 (diffy (- heady taily))
	 (ishori (or (equalp dir "L") (equalp dir "R")))
	 (isvert (or (equalp dir "U") (equalp dir "D"))))
    (if (and (equalp (abs diffx) (abs diffy)) (< 1 (abs diffx)))
	(list (+ tailx (/ diffx (abs diffx))) (+ taily (/ diffy (abs diffy))))
	(if (and isvert (< 1 (abs diffx)))
	    (list (+ tailx (/ diffx (abs diffx))) heady)
	    (if (and ishori (< 1 (abs diffy)))
		(list headx (+ taily (/ diffy (abs diffy))))
		tail)))))
(defun move (dir pos)
  (if (equalp dir "D")
      (list (1+ (car pos)) (cadr pos))
      (if (equalp dir "U")
	  (list (1- (car pos)) (cadr pos))
	  (if (equalp dir "L")
	      (list (car pos) (1- (cadr pos)))
	      (if (equalp dir "R")
		  (list (car pos) (1+ (cadr pos))))))))
(defun count-unique (positions)
  (let ((board (make-array '(1000 1000))))
    (dolist (pos positions)
      (setf (aref board (car pos) (cadr pos)) 1))
    (loop for i below (array-dimension board 0)
	  sum (loop for j below (array-dimension board 1)
		    sum (aref board i j)))))
(defun parse-file (path)
  (with-open-file (inp path)
    (loop for line = (read-line inp nil nil)
	  while line
	  collect line)))

(defun part1 (data)
  (let* ((start '(500 500))
	 (head '(500 500))
	 (tail '(500 500))
	 (visited '()))
    (dolist (command data)
      (let* ((data (uiop:split-string command :separator '(#\space)))
	     (direction (car data))
	     (amount (parse-integer (cadr data))))
      (loop for i from 1 to amount
	    do (progn (setf head (move direction head))
		      (setf tail (follow head tail direction))
		      (setf visited (cons tail visited))))))
  (count-unique visited)))

(defun follow-points (head tails)
  (if tails
      (let* ((cur-h (caar tails))
	     (dir (if (< 1
			 (abs (- cur-h (car head))))
		      "U"
		      "R"))
	     (new-entry (follow head (car tails) dir)))
	(cons new-entry (follow-points new-entry (cdr tails))))
      nil))
(defun get-last-tail (tails)
  (if (cdr tails)
      (get-last-tail (cdr tails))
      (car tails)))

(defun part2 (data)
  (let* ((start '(500 500))
	 (head '(500 500))
	 (tails (loop for i below 9 collect '(500 500)))
	 (visited '()))
    (dolist (command data)
      (let* ((data (uiop:split-string command :separator '(#\space)))
	     (direction (car data))
	     (amount (parse-integer (cadr data))))
	(loop for i from 1 to amount
	      do (progn (setf head (move direction head))
			(setf tails (follow-points head tails))
			(setf visited (cons (get-last-tail tails) visited))))))
    (count-unique visited)))

(defvar problem-input (parse-file "./resources/input"))
(format t "~&Part 1: ~d" (part1 problem-input))
(format t "~&Part 2: ~d~&" (part2 problem-input))
